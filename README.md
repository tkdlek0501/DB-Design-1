# DB-Design-1

## 데이터베이스 설계의 첫걸음

### 설계의 필요성
- 프로젝트 초기에 큰 생각없이 DB 설계를 진행한다면 개발 속도도 빠르고 효율적이라고 보일 수 있다.
- 하지만, 서비스가 점점 커지며 데이터가 많아지면 문제가 눈덩이처럼 불어나기 시작한다.
- 데이터가 중복 저장돼서 정합성이 맞지 않거나, 작은 데이터 변경 건에도 수십 건의 파일을 수정해야 하거나 특히 애플리케이션 속도가 느려져 사용자수가 감소하게 되는 크리티컬한 문제에 직면하게 된다.
- 즉 생각없이 설계한 DB는 곧 기술부채로 이어진다.
- 따라서 튼튼하고 유연하며 오래가는 데이터베이스 시스템을 만드는 방법에 대해 체계적인 원칙과 절차에 따라 데이터 구조를 잡아놔야 한다.

### 설계의 3단계 로드맵
- 아이디어를 실제 데이터베이스로 만들어가는 전체 과정은 크게 개념적 설계 -> 논리적 설계 -> 물리적 설계라는 그림을 이해하고 진행해야 한다.

### 개념적/논리적 모델링
- 요구 사항을 분석해서 핵심 데이터를 찾아내고(엔티티), 그 데이터들이 가지는 속성을 정의하며, 데이터들 간의 관계를 명확하게 표현하는 방법을 배워야 한다. ERD(Entity-Relationship Diagram) 작성법, 다양한 Key의 종류와 역할, 관계의 종류와 식별 및 비식별 관계 등에 대해 깊이 있게 배워야 한다. 이 기본적인 개념을 바탕으로 설계를 해야 미래에 DB의 수정이 필요하더라도 유연하고 빠르게 대응할 수 있다.

### 정규화
- 데이터의 중복을 제거하고 무결성을 높여 모델의 품질을 한 단계 끌어올리는 것이다.

### 물리적 모델링
- 최종적으로 완성된 논리 모델을 실제 데이터베이스에 최적화된 테이블로 만드는 방법을 배워야 한다.

### 왜 다른 것보다 DB 설계를 실무 개발에서 가장 중요한 것으로 뽑는지?
- Java나 Python 같은 애플리케이션 코드는 상대적으로 수정하기 쉽다. 최신 프레임워크와 아키텍처 패턴 덕분에 기능 개선이나 코드 리팩토링이 과거보다 훨씬 유연해졌다. 하지만 데이터베이스 스키마, 즉 테이블의 구조는 한 번 잘못 만들어지면 바로잡는데 엄청난 비용과 시간이 소요된다. 
- DB 재설계는 건축물에서 기둥을 건드는 것과 마찬가지이다.
- 특히 현대적인 관점에서는 비즈니스 요구사항이 급속도로 변경되기 때문에 과거에 남겨진 정보나 지식으로 DB 설계를 그대로 따라하는 것에는 위험성이 있다. 현대의 DB 설계 방법론을 따라야한다.

## 잘못된 설계가 부르는 재앙

### 잘못된 설계가 부르는 재앙
#### 무엇이 '나쁜 설계'인가?
- 극단적인 예시부터 보자면 orders 테이블 하나를 만들어 주문뿐만 아니라 회원, 상품 등을 모두 컬럼으로 관리한다고 생각해보자.
- 데이터예시
  
| order_id | customer_id | customer_name | customer_address | product_id | product_name | product_price | 
|------|------|------|------|------|------|------|
| 1001 | user1 | 네이트 | 서울시 강남구 | P001 | 좋은 키보드 | 50000 |  
| 1002 | user2 | 이철수 | 경기도 성남시 | P002 | 편한 마우스 | 30000 |
| 1003 | user1 | 네이트 | 서울시 강남구 | P002 | 편한 마우스 | 30000 |
| 1004 | user3 | 박영희 | 서울시 서초구 | P003 | 고성능 모니터 | 200000 |
| 1005 | user1 | 네이트 | 서울시 강남구 | P003 | 고성능 모니터 | 200000 |

#### 나쁜 설계의 3대 문제점
- 나쁜 설계는 크게 세 가지 문제를 일으킨다. 바로 데이터 무결성 훼손, 성능 저하, 그리고 유지보수 비용 증가다.
1. 데이터 무결성 훼손 (신뢰도 하락)

   [데이터 중복]
   ```sql
    -- customer_id = 'user1' 에 대해 customer_address 를 수정하는 쿼리
    UPDATE *
    SET customer_address = '제주시 애월읍'
    WHERE customer_id = 'user1';
   ```
   위 쿼리를 실행하면 당연히 데이터가 잘 변경된다. 하지만 쿼리를 실수한다면?
   ```sql
    UPDATE *
    SET customer_address = '제주시 애월읍'
    WHERE order_id = 1005;
   ```
   이게 과연 단순히 쿼리를 잘못 날려서 생긴 문제일까? 하나의 정보를 바꾸기 위해 여러 데이터를 수정해야 하고, 그 과정에서 일부가 누락될 때 데이터가 불일치가 발생한 상황이다. 설계를 제대로 했으면 이런 실수를 방지할 수 있다.

   [삽입 이상]
   
   갑자기 요구사항에 주문하기 전 유저를 등록해야 하는 상황이 생겼다. 예를 들어 첫주문 쿠폰을 발행하기 위해 미리 유저를 등록해야 한다면
   ```sql
   INSERT INTO orders (customer_id, customer_name, customer_address)
   VALUES ('user4', '션', '부산시 해운대구');
   ```
   이렇게 냅다 쿼리를 날려도 될까? 주문 테이블에 아직 주문을 하기 전이니까 null이 들어가게 되는 값이 생길텐데 만약 not null 조건이 있다면 INSERT 구문이 실패하게 되어 주문을 하지 않으면 고객 정보를 등록할 수 없는 모순이 발생한다. 이것을 삽입 이상이라고 한다.

   [삭제 이상]
   
   회원이 시간이 흘러 주문 정보 삭제를 요청했다고 해보자. 그럼 주문 테이블에
   ```sql
   DELETE FROM orders WHERE customer_id = 'user2';
   ```
   이렇게 쿼리를 날려야 한다.
   하지만 이 쿼리를 실행하는 순간 이 유저의 정보는 시스템 상에서 완전히 사라져 버린다.
   나중에 데이터 분석을 위해 '과거에 어떤 고객들이 있었지?' 등에 대해 알고 싶어도 주문 내역을 삭제하는 순간 고객 정보까지 함께 소멸되어 더 이상 찾을 수 없게된다.

2. 성능 저하(속도 저하)

   서비스가 성장하면서 orders 테이블에는 수억 건의 데이터가 쌓였다고 해보자. 이제 이 거대한 테이블에서 데이터를 조회하는 속도가 눈에 띄게 느려지기 시작한다.
   고객 정보만 꺼내오고 싶어도 주문, 상품 정보까지 한꺼번에 들고 와야하니, 디스크에서 읽어야 할 데이터의 양이 많아져 당연히 속도는 느려진다.

3. 유지보수 비용 증가

   비즈니스는 계속 변한다. 새로운 요구 사항이 생길 때마다 데이터베이스 구조도 함께 발전해야 한다. 하지만 잘못된 설계는 이 변화에 발목을 잡는다.
   만약 고객별 등급을 관리하고 싶다는 새로운 요구 사항이 인입됐다고 해보자, 이 간단한 등급 정보를 추가하려면 어떻게 해야할까? orders 테이블에 customer_grade 라는 컬럼을 추가해야 한다.
   ```sql
   ALTER TABLE orders ADD COLUMN customer_grade VARCHAR(10);
   ```
   그리고 '네이트' 고객의 등급을 'GOLD'로 올리려면, 그의 모든 주문 데이터를 일일이 찾아가며 등급을 수정해야 한다.
   ```sql
   UPDATE orders SET customer_grade = 'GOLD' WHERE customer_id = 'user1';
   ```
   앞서 살펴본 수정 이상 문제가 여기서도 동일하게 발생한다. 더 큰 문제는, 고객과 관련된 아주 작은 정보 하나를 추가했을 뿐인데, 수억 건의 주문 데이터가 담긴 거대한 orders 테이블의 구조를 변경해야 한다는 점이다. 이는 데이터베이스에 엄청난 부하를 주는 위험한 작업이 될 수 있다.


## 설계의 3단계 - 개념, 논리, 물리

### 목표
#### 1단계: 개념적 설계

목표 : 비즈니스의 아이디어나 요구 사항을 이해하고, 현실 세계의 정보들을 컴퓨터 세상의 언어로 번역하기 위한 밑그림을 그리는 단계다.

핵심 질문 : "우리가 다루어야 할 데이터는 무엇이며(Entity), 그 데이터들은 서로 어떤 관계(Relationship)을 맺고 있는가?"

핵심 : 개발자만 아는 지식을 가지고 만드는 게 아니라 구성원(개발, 기획, 사업 등)들이 모여서 뭐를 만들 것인지 얘기할 수 있는 단계로써 이해해야 한다.

산출물 : ERD

#### 2단계 : 논리적 설계

목표 : 개념적 설계에서 만든 밑그림을, 우리가 사용하려는 데이터베이스 기술인 '관계형 데이터베이스'의 원리에 맞게 구체적인 구조로 다듬는 단계다.

핵심 질문 : "개념 모델의 각 요소들을 어떤 테이블 구조로 표현할 것인가? 데이터의 중복을 막고 관계를 명확히 하기 위해 어떤 규칙을 적용해야 하는가?"

핵심 : 관계형 데이터베이스 원리에 맞게 논리적으로 구조를 잡는 단계이고, 성능이나 효율에 대해서 깊이 생각하는 단계는 마지막 물리적 설계에서 진행한다.

산출물 : 정규화된 테이블 스키마

#### 3단계 : 물리적 설계

목표 : 논리적 설계에서 만든 테이블 스키마를, 실제 우리가 사용할 특정 RDBMS의 특성에 맞게 최적화하여 구현하는 마지막 단계다.

핵심 질문 : "각 컬럼에 어떤 데이터 타입을 할당해야 가장 효율적일까? 어떤 컬럼에 인덱스를 설정해야 조회 속도가 빨라질까?"

핵심 : 정해놓은 DB 특성에 맞게 성능, 효율 등에 대해 구체적으로 구조를 잡는 단계이다.

산출물 : SQL 스크립트, 물리적인 테이블 정의서

### 용어 정리
#### 개념 모델 : "어떤 집을 원하는가?" (비즈니스 관점, 비개발직군과 어떻게 얘기할 것인지)

목표 : 비즈니스 요구 사항을 이해하고, 핵심 데이터가 무엇인지 정의하는 것. 개발자뿐만 아니라 기획자, 현업 담당자 등 비전문가와 소통하는 것이 주된 목적이다.

핵심 : 테이블, 기본키, 외래키 같은 기술 용어를 사용한다면 비개발직군과의 원활한 소통은 어렵다. 오로지 개념 모델을 가지고 얘기를 잘해놔야 한다.

#### 논리 모델 : "어떻게 구조를 잡을 것인가?" (관계형 데이터베이스 구조 관점)

목표 : 개념 모델에서 파악한 요구 사항을 관계형 데이터베이스 이론에 맞게 체계적으로 구조화하는 것. 특정 데이터베이스 제품에 종속되지 않는, 표준화된 설계도를 만드는 단계이다.

핵심 : 테이블 간의 연결을 구현하는 구체적인 기술인 기본키, 외래키로 관계를 명시한다. 특히 M:N 관계를 연결 테이블로 해소하는 등, 관계형 데이터베이스의 규칙에 맞게 데이터를 정규화하는 중요한 작업이 이 단계에서 이루어진다.

#### 물리 모델 : "어떤 자재로 어떻게 시공할 것인가?" (물리적 구현 관점)

목표 : 논리 모델에서 만든 설계도를 특정 데이터베이스 시스템에 실제로 구현할 수 있도록 구체적인 명세를 정하는 것.

핵심 : 컬럼 별로 어떤 타입에 어떤 길이로, 어떻게 인덱스를 쓸지, 엔진 옵션은 어떤 걸 사용할지, 제약 조건은 어떻게 할지 등 해당 DBMS가 제공하는 기능을 최대한 활용하여 최적의 성능과 안정성을 낼 수 있도록 설계한다.

#### 요약 및 다음 단계

좋은 설계는 '비용'이 아니라 '투자'다. 초반에 들이는 설계 시간은 미래에 발생할 엄청난 재앙을 막고, 시스템의 수명을 늘리는 가장 현명한 투자다.

DB 설계 단계에서는 기획에서 원하는 요구 사항에 정확히 맞는 DB 구조를 만들어두는 게 중요하다. 설계 단계에서 고치면 비용이 적게 들지만, 이미 코딩 까지 다 진행한 뒤 고치려면? 그건 예상치 못한 큰 비용이 들 수 있다.

### 개념적 모델링

#### 요구 사항 분석과 핵심 요소 식별

개념적 모델링은 개발자, 기획자, 현업 담당자 등 모두가 함께 모여 '우리가 만들려는 세상은 이런 모습입니다'라고 협의하는 과정이다. 기술적인 용어 대신, 모두가 이해할 수 있는 그림과 용어로 소통하며 생각의 차이를 좁히고, 우리가 만들어야 할 것의 본질을 명확히 하는 가장 중요한 단계이다.

**요구 사항 분석**

- 모든 설계는 요구 사항 분석에서 시작한다.
- 설계를 하는데 아주 효과적인 방법은 바로 '명사'와 '동사'에 집중하는 것이다.
- 명사 : 우리가 관리해야 할 데이터의 대상, 즉 엔티티 또는 그 엔티티가 가지는 속성이 될 확률이 높다.
- 동사 : 데이터들 사이의 행위나 관계, 즉 Relationship이 될 확률이 높다.

**엔티티 도출하기**

- 저장할 가치가 있는 중요 데이터를 가지고 있으면서, 다른 것과 명확히 구별되는 대상이다.
- 엔티티를 찾는 쉬운 방법은 먼저 명사에서 시작하는 것이다.
- 단, 주의해야할 점은 '명사'가 중요한게 아니라 동사든 명사든 '시스템이 정보를 저장하고 관리해야 할 대상'이 되는지에 대한 검토가 필요하다는 것이다.

#### 엔티티란?

**유형 엔티티**

- 사람, 사물, 장소와 같이 물리적인 형태가 있는, 우리가 직접 만지거나 볼 수 있는 대상을 의미한다.

**무형 엔티티**

- 물리적인 형태는 없지만, 개념적으로 존재하는 관리 대상을 의미한다. 주로 어떤 '사건'이나 '개념'을 데이터로 관리할 때 나타난다.

**좋은 엔티티가 가지는 특성** 

1. 업무 관련성

  엔티티는 반드시 해당 업무에 필요하고 관리해야 하는 정보여야 하며, 업무 프로세스에 의해 이용되어야 한다.

2. 식별 가능해야 한다

  엔티티에 속하는 각각의 데이터는 서로 명확하게 구분될 수 있어야 한다. '회원'시트에 회원명이 똑같은 '네이트'가 두 명 있을 수 있다. 이 때 우리는 이 두 명을 구분할 수 있는 방법이 필요하다. 예를 들어, 각 회원에게 고유한 회원번호나 아이디를 부여하는 것이다. 이것이 나중에 식별자 또는 기본 키가 된다.

3. 두 개 이상의 정보를 가진다

  엔티티는 관리할 만한 가치가 있는 여러 정보, 즉 속성을 가진다. 엑셀 시트의 '열'에 해당한다. '회원'이라는 엔티티는 회원명, 주소, 연락처, 가입일 등 여러 속성을 가진다. 만약 어떤 대상이 단 하나의 정보만 가지고 있다면, 그것은 엔티티가 아니라 다른 엔티티의 일부인 '속성'일 가능성이 높다.

4. 인스턴스의 집합이다

  엔티티는 개념적인 틀이고, 그 틀에 따라 만들어진 실제 데이터 하나하나를 인스턴스라고 부른다.
  엔티티는 영속적으로 존재하는 두 개 이상의 인스턴스로 구성된 집합이어야 한다.

5. 다른 엔티티와 관계를 맺는다

    엔티티는 홀로 존재하지 않고, 다른 엔티티와 서로 관계를 맺는다. 회원은 주문을 하고 주문은 여러 상품을 포함하는 것처럼 관계를 맺고 있다. 이 관계를 파악하는 것이 데이터베이스 설계의 핵심이다. (물론 가끔 관계를 맺지 않는 엔티티도 존재할 수 있다.)


Tip. 실무 팁 - 과도한 설계

- 강의 상 요구 사항에 관리자(또는 판매자)라는 명사가 있을 수 있다. 하지만 엔티티로 도출하지 않았다. 요구 사항에서는 상품 등록의 주체로만 언급될 뿐, 판매자별로 정산을 하거나 판매자 정보를 따로 관리하는 기능이 없다. 이런 경우, 초기 모델에서는 회원 엔티티에 '관리자'역할을 부여하는 컬럼(role 등)을 하나 추가해서 구분하는 것이 더 단순하고 효율적이다. 프로젝트가 성장하여 여러 판매자가 입점하는 '오픈 마켓' 형태로 발전한다면, 그때 판매자를 별도의 엔티티로 분리하는 모델링 변경을 고려하면 된다. 처음부터 모든 가능성을 대비하여 복잡하게 설계하는 것은 오버 엔지니어링일 수 있다.

#### 엔티티 분류

**존재 형태에 따른 분류: 유형, 개념, 사건 엔티티**

1. 유형 엔티티

  유형 엔티티는 물리적인 형태를 가지고 있어 눈으로 보거나 만질 수 있는 실체를 표현하는 엔티티이다. 
  
  특징: 
  
    물리적 형태가 존재한다.

    업무로부터 식별이 용이하다.

    상대적으로 안정적이며 지속적으로 활용되는 정보를 담는다.

  예시:

    사원, 학생, 고객, 교수 (사람)

    상품, 자재, 물품, 차량, 건물 (사물)

    강의실, 창고 , 지점 (장소)

2. 개념 엔티티

  물리적인 형태는 없지만, 업무적으로 관리해야 할 중요한 개념이나 아이디어를 표현하는 엔티티이다. 눈에 보이지 않기 떄문에 유형 엔티티에 비해 식별하기가 다소 까다로울 수 있으며, 비즈니스 프로세스에 대한 깊이 있는 이해를 필요로 한다.

  특징:

    물리적 형태가 없는 추상적인 개념이다.

    업무 규칙이나 제도, 분류 기준 등을 표현한다.

    유형 엔티티와 마찬가지로 비교적 안정적인 정보를 관리한다.

  예시:

    부서, 조직, 팀 (조직 구조)

    계좌, 보험상품 (금융 상품 및 장부)

    과목, 학과 (교육 및 분류 체계)

3. 사건 엔티티(이벤트 엔티티)

   업무 프로세스가 진행됨에 따라 발생하는 특정 행위나 사건을 표현하는 엔티티이다. 특정 시점에 발생하며, 비즈니스 활동의 결과를 기록하는 역할을 한다. 따라서 사건 엔티티는 시간이 지남에 따라 데이터가 지속적으로 누적되는 특징을 가지며, 각종 통계 및 분석 자료의 핵심 소스가 된다.

   특징:

     업무 수행에 따라 발생하는 행위를 기록한다.

     사건의 흐름에 따라 인스턴스가 계속해서 발생한다.

     발생량이 많고, 각종 통계 자료에 활용될 수 있다.

   예시:

     주문, 계약, 청구, 매출 (판매 및 계약 관련 사건)

     결제, 입금, 출금, 미납 (재무 관련 사건)

     수강신청, 예약, 취소, 사고접수 (서비스 관련 사건)

위 3가지 엔티티에 대한 개념에 따라 어떤 엔티티가 시스템 내에서 점유율이 높은지 정리해보면, 이 시스템의 최종 목적과 정체성을 엿볼 수 있다. 예를 들어 사건 엔티티가 많이 존재한다면, 어떤 장부를 관리하는 시스템일 것이고, 반대로 유형이나 개념 엔티티가 많다면 '기준 정보'나 '고객 명단'을 관리하는 시스템일 가능성이 높다.

데리터의 성격과 증가 추이를 미리 파악하면, 주문 같은 테이블을 설계할 때부터 다음과 같은 전략을 세울 수 있다.

- 인덱스 전략
- 데이터 파티셔닝 및 아카이빙

**역할 및 발생 시점에 따른 분류: 기본, 중심, 행위 엔티티 **

비즈니스 프로세스 내에서 수행하는 역할과 데이터가 생성되는 시점에 따라 계층적으로 분류할 수 있다. 이 분류법은 데이터의 발생 순서와 의존성을 명확히 하여 모델의 논리적 흐름을 체계화한다. 일반적으로 기본 엔티티, 중심 엔티티, 행위 엔티티로 구분한다.

1. 기본 엔티티

   업무에 원래부터 존재하는 정보로서, 다른 엔티티에 의해 생성되지 않고 독립적으로 존재할 수 있는 핵심적인 엔티티다. '키 엔티티'라고도 불리며, 일반적으로 다른 엔티티의 부모 역할을 수행한다. 기본 엔티티는 다른 엔티티로부터 주식별자를 상속받지 않고 자신만의 고유한 주식별자를 가진다는 특징이 있다.

  특징:

      독립적으로 생성이 가능하다.

      주로 다른 엔티티의 부모 역할을 한다.

      자신만의 고유한 주식별자를 가진다.

  예시:

    회원, 상품, 사원, 부서, 고객, 자재

2. 중심 엔티티

   기본 엔티티로부터 파생되어 생성되며, 해당 업무에서 중심적인 역할을 수행하는 엔티티다. 이들은 독립적으로 존재하기보다는 기본 엔티티 간의 관계에서 발생하는 핵심적인 비즈니스 트랜잭션을 나타내는 경우가 많다. 따라서 데이터 발생량이 많고, 다른 엔티티와의 관계를 통해 수많은 행위 엔티티를 생성하는 허브 역할을 한다.

  특징:

    기본 엔티티로부터 발생한다.

    업무 프로세스의 중심적인 역할을 담당한다.

    데이터 발생량이 많고, 많은 행위 엔티티를 파생시킨다.

  예시:

    주문, 계약, 청구, 매출

3. 행위 엔티티

  두 개 이상의 부모 엔티티로부터 발생하며, 업무가 흘러가면서 생성되는 상세 정보를 기록하는 엔티티다. 이들은 내용이 자주 변경되거나 데이터양이 지속적으로 가하는 특징을 가지며, 모델 내에서 데이터양이 가장 많은 엔티티가 되는 경우가 많다.

  특징:

    두 개 이상의 부모 엔티티로부터 발생한다.

    데이터 내용이 자주 변경되거나 데이터양이 빠르게 증가한다.

    상세 설계 단계에서 도출되는 경우가 많다.

  예시:

    주문 이력, 신청변경이력, 결제 내역, 로그, 주문 항목

이런 분류가 실제 개발할 때 어떤 도움이 될까?

1. 모델의 이해도와 커뮤니케이션 비용 감소

   프로젝트는 여러 직군의 사람들과 협업해야 한다. 이때 각 개념들에 대해서 특정 엔티티라고 정의하면, 모두가 데이터의 위계와 흐름을 동일한 관점에서 이해할 수 있다.

2. 체계적인 개발 순서와 일정 관리

   엔티티 분류는 그대로 개발의 우선순위가 된다. 당연히 독립적으로 존재하는 기본 엔티티 관련 기능부터 개발 해야 한다. 그 다음은 중심 엔티티, 마지막으로 행위 엔티티 기능을 구현하는 것이 자연스러운 순서다. 이렇게 하면 의존성 문제없이 안정적으로 시스템을 구축할 수 있다.

3. 성능과 데이터 관리 전략 수립의 기준

   엔티티의 특성은 곧 데이터의 특성을 의미한다.

   기본 엔티티: 데이터 변경이 잦지 ㅇ낳고, 주로 조회 작업이 많기 때문에 조회 성능에 최적화된 인덱싱 전략이 중요하다.

   중심 엔티티: 조회의 중심축이자 트랜잭션의 핵심이다. 조회뿐만 아니라 업데이트도 빈번하게 일어난다. 따라서 다양한 검색 조건에 대한 인덱스 전략이 매우 중요하다.

   행위 엔티티: 데이터가 폭발적으로 증가하며, 가장 많은 저장 공간을 차지하게 될 테이블이다. 따라서 설계초기부터 데이터 파티셔닝이나 주기적인 아카이빙 전략을 고민해야 한다.

실무 관점에서 보자면, 파티셔닝/ 아카이빙? 이런 고민을 하는 건 너무 오버 엔지니어링이다. 프로젝트 초기에는 빠르게 정확하게 개발하는 것이 훨씬 중요하다.

그리고 중심엔티티? 사건엔티티? 이런 학술적인 용어는 사용하지 않는다. 그러면 왜 배우는 걸까?
이 분류법은 데이터베이스를 설계하는 '사고의 틀'을 제공한다. 가 테이블이 가지는 데이터의 '본질'과 '생각'을 빠르고 정확하게 간파하는 훈련을 하는 것이다. 숙련된 개발자는 이런 용어를 사용하지 않아도, 테이블 설계를 보면 본능적으로 그 성격을 파악하고 그에 맞는 전략을 구사한다. 우리가 이 개념을 배우는 것은, 바로 그 '본능적인' 전문가의 사고방식을 체계적으로 따라가기 위함이다.

정리하자면, 엔티티 분류는 실무에서 사용하는 '용어'라기보다는, 복잡한 요구 사항 속에서 데이터의 구조와 성격을 꿰뚫어 보고, 미래에 발생할 문제를 예측하며, 최적의 해결책을 찾아가는 과정에서 '설계 지도'가 되어준다.

**강한 엔티티와 약한 에티티**

1. 강한 엔티티

   다른 어떤 엔티티의 존재 여부와 관계없이 독립적으로 존재할 수 있는 엔티티를 의미한다. 즉, 자신의 존재를 위해 다른 엔티티에 의존하지 않는다. 강한 엔티티는 자신을 유일하게 식별할 수 있는 고유한 속성 또는 속성들의 집합, 즉 기본 키를 가지고 있다.

   특징:

     독립적인 존재가 가능하다.

     자신만의 고유한 주식별자를 가진다.

     다른 엔티티의 존재에 의존하지 않는다.

   예시:

     사원, 고객, 상품, 부서 등과 같이 독립적으로 관리할 수 있는 대부분의 엔티티

2. 약한 엔티티

   다른 엔티티가 존재하지 않으면 독립적으로 존재할 수 없는, 존재 종속적인 엔티티다.

   특징: 약한 엔티티는 소유 엔티티가 있어야만 자신의 존재가 의미를 가진다.
   식별자 구성: 전통적인 방식에서는 약한 엔티티는 자신을 식별하기 위해 소유 엔티티의 주식별자를 빌려 자신의 속성(부분키)과 결합하여 주식별자로 삼는다.

강한 엔티티와 약한 엔티티를 왜 구분해야 할까?
부모 엔티티(ex. 사원) 정보가 없는 자식 데이터(부양가족) 즉 고아 데이터가 생겨나면 데이터베이스의 정합성이 깨지고, 인사 관리 시스템 전체가 신뢰를 잃게 된다. 급여, 복지, 세금 등 모든 핵심 기능에 심각한 오류를 초래할 수 있다.
약한 엔티티는 저장할 때 부모의 식별자를 반드시 함께 포함해서 저장해야 한다. 따라서 부모가 존재하지 않는 문제를 설계 단계에서부터 원천 차단할 수 있다.
강한 엔티티와 약한 엔티티의 구분은 바로 이런 데이터 재앙을 설계 단계에서부터 원천적으로 차단하기 위해 존재한다.
엔티티의 독립성을 기준으로 강한 엔티티와 약한 엔티티를 구분하는 것은 테이블의 키와 외래 키 제약조건을 설계하는 데 중요한 역할을 한다.

**구조적 관계 표현을 위한 특수 엔티티**

엔티티 간의 관계가 단순한 연결선을 넘어, 그 자체가 하나의 독립된 의미를 갖는 개념일 때가 있다.
이러한 사건이나 분류와 같은 복잡한 관계를 효과적으로 모델에 반영하기 위해 사용하는 것이 바로 연관 엔티티와 슈퍼타입/서브타입 구조이다.

1. 연관 엔티티

   두 개 이상의 엔티티 간에 발생하는 특정 사건, 행위, 계약 등을 표현하기 위해 도출되는 엔티티이다. 즉, 관계 자체가 중용한 속성을 가져 하나의 독립된 실체로 다뤄져야 할 때 사용된다.

2. 슈퍼타입/ 서브타입 엔티티

   논리적으로 동일한 개념 그룹에 속하지만 일부 속성이나 관계에서 차이가 있는 엔티티들을 효과적으로 표현하기 위한 기법이다. 이는 IS-A 관계(ex. '관리자는 사원의 한 종류이다') 개념과 매우 유사하다.
   상속 관계를 떠올리면 된다.



