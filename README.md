# DB-Design-1

## 데이터베이스 설계의 첫걸음

### 설계의 필요성
- 프로젝트 초기에 큰 생각없이 DB 설계를 진행한다면 개발 속도도 빠르고 효율적이라고 보일 수 있다.
- 하지만, 서비스가 점점 커지며 데이터가 많아지면 문제가 눈덩이처럼 불어나기 시작한다.
- 데이터가 중복 저장돼서 정합성이 맞지 않거나, 작은 데이터 변경 건에도 수십 건의 파일을 수정해야 하거나 특히 애플리케이션 속도가 느려져 사용자수가 감소하게 되는 크리티컬한 문제에 직면하게 된다.
- 즉 생각없이 설계한 DB는 곧 기술부채로 이어진다.
- 따라서 튼튼하고 유연하며 오래가는 데이터베이스 시스템을 만드는 방법에 대해 체계적인 원칙과 절차에 따라 데이터 구조를 잡아놔야 한다.

### 설계의 3단계 로드맵
- 아이디어를 실제 데이터베이스로 만들어가는 전체 과정은 크게 개념적 설계 -> 논리적 설계 -> 물리적 설계라는 그림을 이해하고 진행해야 한다.

### 개념적/논리적 모델링
- 요구 사항을 분석해서 핵심 데이터를 찾아내고(엔티티), 그 데이터들이 가지는 속성을 정의하며, 데이터들 간의 관계를 명확하게 표현하는 방법을 배워야 한다. ERD(Entity-Relationship Diagram) 작성법, 다양한 Key의 종류와 역할, 관계의 종류와 식별 및 비식별 관계 등에 대해 깊이 있게 배워야 한다. 이 기본적인 개념을 바탕으로 설계를 해야 미래에 DB의 수정이 필요하더라도 유연하고 빠르게 대응할 수 있다.

### 정규화
- 데이터의 중복을 제거하고 무결성을 높여 모델의 품질을 한 단계 끌어올리는 것이다.

### 물리적 모델링
- 최종적으로 완성된 논리 모델을 실제 데이터베이스에 최적화된 테이블로 만드는 방법을 배워야 한다.

### 왜 다른 것보다 DB 설계를 실무 개발에서 가장 중요한 것으로 뽑는지?
- Java나 Python 같은 애플리케이션 코드는 상대적으로 수정하기 쉽다. 최신 프레임워크와 아키텍처 패턴 덕분에 기능 개선이나 코드 리팩토링이 과거보다 훨씬 유연해졌다. 하지만 데이터베이스 스키마, 즉 테이블의 구조는 한 번 잘못 만들어지면 바로잡는데 엄청난 비용과 시간이 소요된다. 
- DB 재설계는 건축물에서 기둥을 건드는 것과 마찬가지이다.
- 특히 현대적인 관점에서는 비즈니스 요구사항이 급속도로 변경되기 때문에 과거에 남겨진 정보나 지식으로 DB 설계를 그대로 따라하는 것에는 위험성이 있다. 현대의 DB 설계 방법론을 따라야한다.

## 잘못된 설계가 부르는 재앙

### 잘못된 설계가 부르는 재앙
#### 무엇이 '나쁜 설계'인가?
- 극단적인 예시부터 보자면 orders 테이블 하나를 만들어 주문뿐만 아니라 회원, 상품 등을 모두 컬럼으로 관리한다고 생각해보자.
- 데이터예시
  
| order_id | customer_id | customer_name | customer_address | product_id | product_name | product_price | 
|------|------|------|------|------|------|------|
| 1001 | user1 | 네이트 | 서울시 강남구 | P001 | 좋은 키보드 | 50000 |  
| 1002 | user2 | 이철수 | 경기도 성남시 | P002 | 편한 마우스 | 30000 |
| 1003 | user1 | 네이트 | 서울시 강남구 | P002 | 편한 마우스 | 30000 |
| 1004 | user3 | 박영희 | 서울시 서초구 | P003 | 고성능 모니터 | 200000 |
| 1005 | user1 | 네이트 | 서울시 강남구 | P003 | 고성능 모니터 | 200000 |

#### 나쁜 설계의 3대 문제점
- 나쁜 설계는 크게 세 가지 문제를 일으킨다. 바로 데이터 무결성 훼손, 성능 저하, 그리고 유지보수 비용 증가다.
1. 데이터 무결성 훼손 (신뢰도 하락)

   [데이터 중복]
   ```sql
    -- customer_id = 'user1' 에 대해 customer_address 를 수정하는 쿼리
    UPDATE *
    SET customer_address = '제주시 애월읍'
    WHERE customer_id = 'user1';
   ```
   위 쿼리를 실행하면 당연히 데이터가 잘 변경된다. 하지만 쿼리를 실수한다면?
   ```sql
    UPDATE *
    SET customer_address = '제주시 애월읍'
    WHERE order_id = 1005;
   ```
   이게 과연 단순히 쿼리를 잘못 날려서 생긴 문제일까? 하나의 정보를 바꾸기 위해 여러 데이터를 수정해야 하고, 그 과정에서 일부가 누락될 때 데이터가 불일치가 발생한 상황이다. 설계를 제대로 했으면 이런 실수를 방지할 수 있다.

   [삽입 이상]
   
   갑자기 요구사항에 주문하기 전 유저를 등록해야 하는 상황이 생겼다. 예를 들어 첫주문 쿠폰을 발행하기 위해 미리 유저를 등록해야 한다면
   ```sql
   INSERT INTO orders (customer_id, customer_name, customer_address)
   VALUES ('user4', '션', '부산시 해운대구');
   ```
   이렇게 냅다 쿼리를 날려도 될까? 주문 테이블에 아직 주문을 하기 전이니까 null이 들어가게 되는 값이 생길텐데 만약 not null 조건이 있다면 INSERT 구문이 실패하게 되어 주문을 하지 않으면 고객 정보를 등록할 수 없는 모순이 발생한다. 이것을 삽입 이상이라고 한다.

   [삭제 이상]
   
   회원이 시간이 흘러 주문 정보 삭제를 요청했다고 해보자. 그럼 주문 테이블에
   ```sql
   DELETE FROM orders WHERE customer_id = 'user2';
   ```
   이렇게 쿼리를 날려야 한다.
   하지만 이 쿼리를 실행하는 순간 이 유저의 정보는 시스템 상에서 완전히 사라져 버린다.
   나중에 데이터 분석을 위해 '과거에 어떤 고객들이 있었지?' 등에 대해 알고 싶어도 주문 내역을 삭제하는 순간 고객 정보까지 함께 소멸되어 더 이상 찾을 수 없게된다.

2. 성능 저하(속도 저하)

   서비스가 성장하면서 orders 테이블에는 수억 건의 데이터가 쌓였다고 해보자. 이제 이 거대한 테이블에서 데이터를 조회하는 속도가 눈에 띄게 느려지기 시작한다.
   고객 정보만 꺼내오고 싶어도 주문, 상품 정보까지 한꺼번에 들고 와야하니, 디스크에서 읽어야 할 데이터의 양이 많아져 당연히 속도는 느려진다.

3. 유지보수 비용 증가

   비즈니스는 계속 변한다. 새로운 요구 사항이 생길 때마다 데이터베이스 구조도 함께 발전해야 한다. 하지만 잘못된 설계는 이 변화에 발목을 잡는다.
   만약 고객별 등급을 관리하고 싶다는 새로운 요구 사항이 인입됐다고 해보자, 이 간단한 등급 정보를 추가하려면 어떻게 해야할까? orders 테이블에 customer_grade 라는 컬럼을 추가해야 한다.
   ```sql
   ALTER TABLE orders ADD COLUMN customer_grade VARCHAR(10);
   ```
   그리고 '네이트' 고객의 등급을 'GOLD'로 올리려면, 그의 모든 주문 데이터를 일일이 찾아가며 등급을 수정해야 한다.
   ```sql
   UPDATE orders SET customer_grade = 'GOLD' WHERE customer_id = 'user1';
   ```
   앞서 살펴본 수정 이상 문제가 여기서도 동일하게 발생한다. 더 큰 문제는, 고객과 관련된 아주 작은 정보 하나를 추가했을 뿐인데, 수억 건의 주문 데이터가 담긴 거대한 orders 테이블의 구조를 변경해야 한다는 점이다. 이는 데이터베이스에 엄청난 부하를 주는 위험한 작업이 될 수 있다.
