# DB-Design-1

## 데이터베이스 설계의 첫걸음

### 설계의 필요성
- 프로젝트 초기에 큰 생각없이 DB 설계를 진행한다면 개발 속도도 빠르고 효율적이라고 보일 수 있다.
- 하지만, 서비스가 점점 커지며 데이터가 많아지면 문제가 눈덩이처럼 불어나기 시작한다.
- 데이터가 중복 저장돼서 정합성이 맞지 않거나, 작은 데이터 변경 건에도 수십 건의 파일을 수정해야 하거나 특히 애플리케이션 속도가 느려져 사용자수가 감소하게 되는 크리티컬한 문제에 직면하게 된다.
- 즉 생각없이 설계한 DB는 곧 기술부채로 이어진다.
- 따라서 튼튼하고 유연하며 오래가는 데이터베이스 시스템을 만드는 방법에 대해 체계적인 원칙과 절차에 따라 데이터 구조를 잡아놔야 한다.

### 설계의 3단계 로드맵
- 아이디어를 실제 데이터베이스로 만들어가는 전체 과정은 크게 개념적 설계 -> 논리적 설계 -> 물리적 설계라는 그림을 이해하고 진행해야 한다.

### 개념적/논리적 모델링
- 요구 사항을 분석해서 핵심 데이터를 찾아내고(엔티티), 그 데이터들이 가지는 속성을 정의하며, 데이터들 간의 관계를 명확하게 표현하는 방법을 배워야 한다. ERD(Entity-Relationship Diagram) 작성법, 다양한 Key의 종류와 역할, 관계의 종류와 식별 및 비식별 관계 등에 대해 깊이 있게 배워야 한다. 이 기본적인 개념을 바탕으로 설계를 해야 미래에 DB의 수정이 필요하더라도 유연하고 빠르게 대응할 수 있다.

### 정규화
- 데이터의 중복을 제거하고 무결성을 높여 모델의 품질을 한 단계 끌어올리는 것이다.

### 물리적 모델링
- 최종적으로 완성된 논리 모델을 실제 데이터베이스에 최적화된 테이블로 만드는 방법을 배워야 한다.

### 왜 다른 것보다 DB 설계를 실무 개발에서 가장 중요한 것으로 뽑는지?
- Java나 Python 같은 애플리케이션 코드는 상대적으로 수정하기 쉽다. 최신 프레임워크와 아키텍처 패턴 덕분에 기능 개선이나 코드 리팩토링이 과거보다 훨씬 유연해졌다. 하지만 데이터베이스 스키마, 즉 테이블의 구조는 한 번 잘못 만들어지면 바로잡는데 엄청난 비용과 시간이 소요된다. 
- DB 재설계는 건축물에서 기둥을 건드는 것과 마찬가지이다.
- 특히 현대적인 관점에서는 비즈니스 요구사항이 급속도로 변경되기 때문에 과거에 남겨진 정보나 지식으로 DB 설계를 그대로 따라하는 것에는 위험성이 있다. 현대의 DB 설계 방법론을 따라야한다.

## 잘못된 설계가 부르는 재앙

### 잘못된 설계가 부르는 재앙
#### 무엇이 '나쁜 설계'인가?
- 극단적인 예시부터 보자면 orders 테이블 하나를 만들어 주문뿐만 아니라 회원, 상품 등을 모두 컬럼으로 관리한다고 생각해보자.
- 데이터예시
  
| order_id | customer_id | customer_name | customer_address | product_id | product_name | product_price | 
|------|------|------|------|------|------|------|
| 1001 | user1 | 네이트 | 서울시 강남구 | P001 | 좋은 키보드 | 50000 |  
| 1002 | user2 | 이철수 | 경기도 성남시 | P002 | 편한 마우스 | 30000 |
| 1003 | user1 | 네이트 | 서울시 강남구 | P002 | 편한 마우스 | 30000 |
| 1004 | user3 | 박영희 | 서울시 서초구 | P003 | 고성능 모니터 | 200000 |
| 1005 | user1 | 네이트 | 서울시 강남구 | P003 | 고성능 모니터 | 200000 |

#### 나쁜 설계의 3대 문제점
- 나쁜 설계는 크게 세 가지 문제를 일으킨다. 바로 데이터 무결성 훼손, 성능 저하, 그리고 유지보수 비용 증가다.
1. 데이터 무결성 훼손 (신뢰도 하락)

   [데이터 중복]
   ```sql
    -- customer_id = 'user1' 에 대해 customer_address 를 수정하는 쿼리
    UPDATE *
    SET customer_address = '제주시 애월읍'
    WHERE customer_id = 'user1';
   ```
   위 쿼리를 실행하면 당연히 데이터가 잘 변경된다. 하지만 쿼리를 실수한다면?
   ```sql
    UPDATE *
    SET customer_address = '제주시 애월읍'
    WHERE order_id = 1005;
   ```
   이게 과연 단순히 쿼리를 잘못 날려서 생긴 문제일까? 하나의 정보를 바꾸기 위해 여러 데이터를 수정해야 하고, 그 과정에서 일부가 누락될 때 데이터가 불일치가 발생한 상황이다. 설계를 제대로 했으면 이런 실수를 방지할 수 있다.

   [삽입 이상]
   
   갑자기 요구사항에 주문하기 전 유저를 등록해야 하는 상황이 생겼다. 예를 들어 첫주문 쿠폰을 발행하기 위해 미리 유저를 등록해야 한다면
   ```sql
   INSERT INTO orders (customer_id, customer_name, customer_address)
   VALUES ('user4', '션', '부산시 해운대구');
   ```
   이렇게 냅다 쿼리를 날려도 될까? 주문 테이블에 아직 주문을 하기 전이니까 null이 들어가게 되는 값이 생길텐데 만약 not null 조건이 있다면 INSERT 구문이 실패하게 되어 주문을 하지 않으면 고객 정보를 등록할 수 없는 모순이 발생한다. 이것을 삽입 이상이라고 한다.

   [삭제 이상]
   
   회원이 시간이 흘러 주문 정보 삭제를 요청했다고 해보자. 그럼 주문 테이블에
   ```sql
   DELETE FROM orders WHERE customer_id = 'user2';
   ```
   이렇게 쿼리를 날려야 한다.
   하지만 이 쿼리를 실행하는 순간 이 유저의 정보는 시스템 상에서 완전히 사라져 버린다.
   나중에 데이터 분석을 위해 '과거에 어떤 고객들이 있었지?' 등에 대해 알고 싶어도 주문 내역을 삭제하는 순간 고객 정보까지 함께 소멸되어 더 이상 찾을 수 없게된다.

2. 성능 저하(속도 저하)

   서비스가 성장하면서 orders 테이블에는 수억 건의 데이터가 쌓였다고 해보자. 이제 이 거대한 테이블에서 데이터를 조회하는 속도가 눈에 띄게 느려지기 시작한다.
   고객 정보만 꺼내오고 싶어도 주문, 상품 정보까지 한꺼번에 들고 와야하니, 디스크에서 읽어야 할 데이터의 양이 많아져 당연히 속도는 느려진다.

3. 유지보수 비용 증가

   비즈니스는 계속 변한다. 새로운 요구 사항이 생길 때마다 데이터베이스 구조도 함께 발전해야 한다. 하지만 잘못된 설계는 이 변화에 발목을 잡는다.
   만약 고객별 등급을 관리하고 싶다는 새로운 요구 사항이 인입됐다고 해보자, 이 간단한 등급 정보를 추가하려면 어떻게 해야할까? orders 테이블에 customer_grade 라는 컬럼을 추가해야 한다.
   ```sql
   ALTER TABLE orders ADD COLUMN customer_grade VARCHAR(10);
   ```
   그리고 '네이트' 고객의 등급을 'GOLD'로 올리려면, 그의 모든 주문 데이터를 일일이 찾아가며 등급을 수정해야 한다.
   ```sql
   UPDATE orders SET customer_grade = 'GOLD' WHERE customer_id = 'user1';
   ```
   앞서 살펴본 수정 이상 문제가 여기서도 동일하게 발생한다. 더 큰 문제는, 고객과 관련된 아주 작은 정보 하나를 추가했을 뿐인데, 수억 건의 주문 데이터가 담긴 거대한 orders 테이블의 구조를 변경해야 한다는 점이다. 이는 데이터베이스에 엄청난 부하를 주는 위험한 작업이 될 수 있다.


## 설계의 3단계 - 개념, 논리, 물리

### 목표
#### 1단계: 개념적 설계

목표 : 비즈니스의 아이디어나 요구 사항을 이해하고, 현실 세계의 정보들을 컴퓨터 세상의 언어로 번역하기 위한 밑그림을 그리는 단계다.

핵심 질문 : "우리가 다루어야 할 데이터는 무엇이며(Entity), 그 데이터들은 서로 어떤 관계(Relationship)을 맺고 있는가?"

핵심 : 개발자만 아는 지식을 가지고 만드는 게 아니라 구성원(개발, 기획, 사업 등)들이 모여서 뭐를 만들 것인지 얘기할 수 있는 단계로써 이해해야 한다.

산출물 : ERD

#### 2단계 : 논리적 설계

목표 : 개념적 설계에서 만든 밑그림을, 우리가 사용하려는 데이터베이스 기술인 '관계형 데이터베이스'의 원리에 맞게 구체적인 구조로 다듬는 단계다.

핵심 질문 : "개념 모델의 각 요소들을 어떤 테이블 구조로 표현할 것인가? 데이터의 중복을 막고 관계를 명확히 하기 위해 어떤 규칙을 적용해야 하는가?"

핵심 : 관계형 데이터베이스 원리에 맞게 논리적으로 구조를 잡는 단계이고, 성능이나 효율에 대해서 깊이 생각하는 단계는 마지막 물리적 설계에서 진행한다.

산출물 : 정규화된 테이블 스키마

#### 3단계 : 물리적 설계

목표 : 논리적 설계에서 만든 테이블 스키마를, 실제 우리가 사용할 특정 RDBMS의 특성에 맞게 최적화하여 구현하는 마지막 단계다.

핵심 질문 : "각 컬럼에 어떤 데이터 타입을 할당해야 가장 효율적일까? 어떤 컬럼에 인덱스를 설정해야 조회 속도가 빨라질까?"

핵심 : 정해놓은 DB 특성에 맞게 성능, 효율 등에 대해 구체적으로 구조를 잡는 단계이다.

산출물 : SQL 스크립트, 물리적인 테이블 정의서

### 용어 정리
#### 개념 모델 : "어떤 집을 원하는가?" (비즈니스 관점, 비개발직군과 어떻게 얘기할 것인지)

목표 : 비즈니스 요구 사항을 이해하고, 핵심 데이터가 무엇인지 정의하는 것. 개발자뿐만 아니라 기획자, 현업 담당자 등 비전문가와 소통하는 것이 주된 목적이다.

핵심 : 테이블, 기본키, 외래키 같은 기술 용어를 사용한다면 비개발직군과의 원활한 소통은 어렵다. 오로지 개념 모델을 가지고 얘기를 잘해놔야 한다.

#### 논리 모델 : "어떻게 구조를 잡을 것인가?" (관계형 데이터베이스 구조 관점)

목표 : 개념 모델에서 파악한 요구 사항을 관계형 데이터베이스 이론에 맞게 체계적으로 구조화하는 것. 특정 데이터베이스 제품에 종속되지 않는, 표준화된 설계도를 만드는 단계이다.

핵심 : 테이블 간의 연결을 구현하는 구체적인 기술인 기본키, 외래키로 관계를 명시한다. 특히 M:N 관계를 연결 테이블로 해소하는 등, 관계형 데이터베이스의 규칙에 맞게 데이터를 정규화하는 중요한 작업이 이 단계에서 이루어진다.

#### 물리 모델 : "어떤 자재로 어떻게 시공할 것인가?" (물리적 구현 관점)

목표 : 논리 모델에서 만든 설계도를 특정 데이터베이스 시스템에 실제로 구현할 수 있도록 구체적인 명세를 정하는 것.

핵심 : 컬럼 별로 어떤 타입에 어떤 길이로, 어떻게 인덱스를 쓸지, 엔진 옵션은 어떤 걸 사용할지, 제약 조건은 어떻게 할지 등 해당 DBMS가 제공하는 기능을 최대한 활용하여 최적의 성능과 안정성을 낼 수 있도록 설계한다.

#### 요약 및 다음 단계

좋은 설계는 '비용'이 아니라 '투자'다. 초반에 들이는 설계 시간은 미래에 발생할 엄청난 재앙을 막고, 시스템의 수명을 늘리는 가장 현명한 투자다.

DB 설계 단계에서는 기획에서 원하는 요구 사항에 정확히 맞는 DB 구조를 만들어두는 게 중요하다. 설계 단계에서 고치면 비용이 적게 들지만, 이미 코딩 까지 다 진행한 뒤 고치려면? 그건 예상치 못한 큰 비용이 들 수 있다.

### 개념적 모델링

#### 요구 사항 분석과 핵심 요소 식별

개념적 모델링은 개발자, 기획자, 현업 담당자 등 모두가 함께 모여 '우리가 만들려는 세상은 이런 모습입니다'라고 협의하는 과정이다. 기술적인 용어 대신, 모두가 이해할 수 있는 그림과 용어로 소통하며 생각의 차이를 좁히고, 우리가 만들어야 할 것의 본질을 명확히 하는 가장 중요한 단계이다.

**요구 사항 분석**

- 모든 설계는 요구 사항 분석에서 시작한다.
- 설계를 하는데 아주 효과적인 방법은 바로 '명사'와 '동사'에 집중하는 것이다.
- 명사 : 우리가 관리해야 할 데이터의 대상, 즉 엔티티 또는 그 엔티티가 가지는 속성이 될 확률이 높다.
- 동사 : 데이터들 사이의 행위나 관계, 즉 Relationship이 될 확률이 높다.

**엔티티 도출하기**

- 저장할 가치가 있는 중요 데이터를 가지고 있으면서, 다른 것과 명확히 구별되는 대상이다.
- 엔티티를 찾는 쉬운 방법은 먼저 명사에서 시작하는 것이다.
- 단, 주의해야할 점은 '명사'가 중요한게 아니라 동사든 명사든 '시스템이 정보를 저장하고 관리해야 할 대상'이 되는지에 대한 검토가 필요하다는 것이다.

#### 엔티티란?

**유형 엔티티**

- 사람, 사물, 장소와 같이 물리적인 형태가 있는, 우리가 직접 만지거나 볼 수 있는 대상을 의미한다.

**무형 엔티티**

- 물리적인 형태는 없지만, 개념적으로 존재하는 관리 대상을 의미한다. 주로 어떤 '사건'이나 '개념'을 데이터로 관리할 때 나타난다.

**좋은 엔티티가 가지는 특성** 

1. 업무 관련성

  엔티티는 반드시 해당 업무에 필요하고 관리해야 하는 정보여야 하며, 업무 프로세스에 의해 이용되어야 한다.

2. 식별 가능해야 한다

  엔티티에 속하는 각각의 데이터는 서로 명확하게 구분될 수 있어야 한다. '회원'시트에 회원명이 똑같은 '네이트'가 두 명 있을 수 있다. 이 때 우리는 이 두 명을 구분할 수 있는 방법이 필요하다. 예를 들어, 각 회원에게 고유한 회원번호나 아이디를 부여하는 것이다. 이것이 나중에 식별자 또는 기본 키가 된다.

3. 두 개 이상의 정보를 가진다

  엔티티는 관리할 만한 가치가 있는 여러 정보, 즉 속성을 가진다. 엑셀 시트의 '열'에 해당한다. '회원'이라는 엔티티는 회원명, 주소, 연락처, 가입일 등 여러 속성을 가진다. 만약 어떤 대상이 단 하나의 정보만 가지고 있다면, 그것은 엔티티가 아니라 다른 엔티티의 일부인 '속성'일 가능성이 높다.

4. 인스턴스의 집합이다

  엔티티는 개념적인 틀이고, 그 틀에 따라 만들어진 실제 데이터 하나하나를 인스턴스라고 부른다.
  엔티티는 영속적으로 존재하는 두 개 이상의 인스턴스로 구성된 집합이어야 한다.

5. 다른 엔티티와 관계를 맺는다

    엔티티는 홀로 존재하지 않고, 다른 엔티티와 서로 관계를 맺는다. 회원은 주문을 하고 주문은 여러 상품을 포함하는 것처럼 관계를 맺고 있다. 이 관계를 파악하는 것이 데이터베이스 설계의 핵심이다. (물론 가끔 관계를 맺지 않는 엔티티도 존재할 수 있다.)


Tip. 실무 팁 - 과도한 설계

- 강의 상 요구 사항에 관리자(또는 판매자)라는 명사가 있을 수 있다. 하지만 엔티티로 도출하지 않았다. 요구 사항에서는 상품 등록의 주체로만 언급될 뿐, 판매자별로 정산을 하거나 판매자 정보를 따로 관리하는 기능이 없다. 이런 경우, 초기 모델에서는 회원 엔티티에 '관리자'역할을 부여하는 컬럼(role 등)을 하나 추가해서 구분하는 것이 더 단순하고 효율적이다. 프로젝트가 성장하여 여러 판매자가 입점하는 '오픈 마켓' 형태로 발전한다면, 그때 판매자를 별도의 엔티티로 분리하는 모델링 변경을 고려하면 된다. 처음부터 모든 가능성을 대비하여 복잡하게 설계하는 것은 오버 엔지니어링일 수 있다.




